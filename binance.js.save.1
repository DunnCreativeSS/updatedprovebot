const Binance = require('binance-api-node').default
var PortfolioAnalytics = require('portfolio-analytics');
var sleep2 = require('system-sleep')

var request = require("request")
var bodyParser = require('body-parser')
const express = require('express');
const app = express();
const client = Binance({
    apiKey: process.env.binApiKey || 'XGjzcjFqDgd06qg6fNpjAIUzzebrbURXup3Z7P1OCXBoq8SoFvnYV0pgCoN69gbG',
    apiSecret: process.env.binApiSecret || 'yZ1oFZFGkJjn3CPK9XsRkuJXQJzKohZPhhv6Jz5GmcsAN1cOVevEWeSLJPBNzlYM'
})

let testing = false;
let renew = {}

let targetSpread = .8;
let targetVolDiv = 6;
let targetVolMult = 2000;
let maxOrder = 1500000;
let maxBetterVol = 1.5;
let neversellataloss = true;
let stoploss = 0.88;
let neversellatalossReductionIntervalMinutes = 10;



let changed = {}

let msg;

let dontbuy = {}    

let bals = {}
let rdiff = 0;
let retdiff = 0;
let rdiffs = []
let retdiffs = []
let returnPortfolio;
let benchmark;
let zeroRisk;
let sharpe;
const binance = Binance({
    apiKey: '',
    apiSecret: ''
})
const {
    PublicClient
} = require("@okfe/okex-node");
const {
    V3WebsocketClient
} = require("@okfe/okex-node");
const {
    AuthenticatedClient
} = require("@okfe/okex-node");
const pClient = new PublicClient();
const wss = new V3WebsocketClient();
wss.connect();

var _ = require("underscore")

var moment = require("moment");


const WebSocket = require('ws');

wss.on('open', function open() {
    //////console.log('opened!');

});
var asks = []
var bids = []
const bfx = require('./bfx.js')
const ws2 = bfx.ws(2, {
    transform: true
})

const rest = bfx.rest(2, {});
 let keys = []
  let keys2 = []
            rest.symbols().then(symbols => {
        for (var s in symbols) {
            //////console.log('t' + symbols[s].toUpperCase());
            if (symbols[s].toUpperCase().slice(-3) == "ETH" || symbols[s].toUpperCase().slice(-3) == "BTC" || symbols[s].toUpperCase().slice(-3) == "USD") {
               if (!keys2.includes('t' + symbols[s].toUpperCase())){
                keys.push('trade:1m:t' + symbols[s].toUpperCase());

                keys2.push('t' + symbols[s].toUpperCase());

}


            }
        }
})
wss.on('message', function incoming(data) {
    try {
        for (var v in JSON.parse(data).data) {
            if (JSON.parse(data).data[v].last) {
                var symbol = JSON.parse(data).data[v].instrument_id.replace('-', '')
                if (asks[symbol] == undefined) {
                    asks[symbol] = []
                    bids[symbol] = []
                }
                if (asks[symbol]['okex'] == undefined) {
                    asks[symbol]['okex'] = JSON.parse(data).data[v].best_ask;
                    bids[symbol]['okex'] = JSON.parse(data).data[v].best_bid;
                }
                asks[symbol]['okex'] = JSON.parse(data).data[v].best_ask;
                bids[symbol]['okex'] = JSON.parse(data).data[v].best_bid;
            }
        }

        gogo['okexTrades'] = true
    } catch (err) {

    }
});


app.use(bodyParser.json()); // to support JSON-encoded bodies
app.use(bodyParser.urlencoded({ // to support URL-encoded bodies
    extended: true
}));


let btcstart = parseFloat(process.env.btcstart) || 0.016503440244819995	
 
let bnbstart = parseFloat(process.env.bnbstart) || 3.986338223386473
let usdstart =  parseFloat(process.env.usdstart) || 66.40984354515567
let btcref = parseFloat(process.env.btcref) || 4018
let bals3 = {}
let balscombined = {}
let bals4 = {}
let least = 99999999999999999999999999999999;
app.set('view engine', 'ejs');
var MongoClient = require('mongodb').MongoClient;
let gocount = 0;
app.listen(process.env.binPORT || 80, function() {});

var sortBy = (function() {
    var toString = Object.prototype.toString,
        // default parser function
        parse = function(x) {
            return x;
        },
        // gets the item to be sorted
        getItem = function(x) {
            var isObject = x != null && typeof x === "object";
            var isProp = isObject && this.prop in x;
            return this.parser(isProp ? x[this.prop] : x);
        };

    /**
     * Sorts an array of elements.
     *
     * @param {Array} array: the collection to sort
     * @param {Object} cfg: the configuration options
     * @property {String}   cfg.prop: property name (if it is an Array of objects)
     * @property {Boolean}  cfg.desc: determines whether the sort is descending
     * @property {Function} cfg.parser: function to parse the items to expected type
     * @return {Array}
     */
    return function sortby(array, cfg) {
        if (!(array instanceof Array && array.length)) return [];
        if (toString.call(cfg) !== "[object Object]") cfg = {};
        if (typeof cfg.parser !== "function") cfg.parser = parse;
        cfg.desc = !!cfg.desc ? -1 : 1;
        return array.sort(function(a, b) {
            a = getItem.call(cfg, a);
            b = getItem.call(cfg, b);
            return cfg.desc * (a < b ? -1 : +(a > b));
        });
    };

}());
var gogo = []

app.post('/', (req, res) => {
    doPost(req, res);

});
// See 'options' reference below
let sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));
let avgBids = {}
setInterval(function(){
for (var symbol in divisor){
    divisor[symbol] = divisor[symbol] * 1.0001
buyOs[symbol] = buyOs[symbol] / divisor[symbol]
}
}, 60 * neversellatalossReductionIntervalMinutes  * 1000)
setInterval(function(){


for (var b in bids) {
    let total = 0;
    let c = 0;
    for( var ex in bids[b]){
        total+=parseFloat(bids[b][ex])
        c++;
    }
    avgBids[b] = total / c
if (divisor[b] != undefined){
//buyOs[b] = buyOs[b] / divisor[b]
}
}
}, 15000)
setTimeout(async function() {


    for (var p in pairs) {

        wss.subscribe("spot/ticker:" + pairs[p].replace('/', '-'));
        sleep2(2)
        doOthers({
            symbol: pairs[p]
        });
    }

}, 10000);
let pairs = []
binance.ws.allTickers(tickers => {
    for (var t in tickers) {
        if (asks[tickers[t].symbol] == undefined) {
            asks[tickers[t].symbol] = {}
            bids[tickers[t].symbol] = {}
        }
        let pair;
        if (tickers[t].symbol.substring(tickers[t].symbol.length - 4, tickers[t].symbol.length).startsWith('USD')) {
            pair = tickers[t].symbol.substring(0, tickers[t].symbol.length - 4) + '/' + tickers[t].symbol.substring(tickers[t].symbol.length - 4, tickers[t].symbol.length);
        } else {
            pair = tickers[t].symbol.substring(0, tickers[t].symbol.length - 3) + '/' + tickers[t].symbol.substring(tickers[t].symbol.length - 3, tickers[t].symbol.length);

        }
        if (!pairs.includes(pair)) {
            pairs.push(pair);
        }
        asks[tickers[t].symbol]['binance'] = tickers[t].bestAsk
        bids[tickers[t].symbol]['binance'] = tickers[t].bestBid
    }
})

async function doOthers(mv) {

    var pair = mv.symbol.replace('/', '')
    if (pair.slice(-3) == "USD") {
        pair += "T"
    }
    var ts = Math.round(new Date().getTime() / 1000);
    var tsYesterday = ts - (0.005 * 3600);

    if (pair == "BTCUSDT") {
        var p = "XBTUSD";
    } else {
        var p = pair;
    }
    var opts = {
        'symbol': p,
        'startTime': moment(tsYesterday * 1000).format()
    };
    //////console.log(opts);

    var pd = pair.split('/')[0]
    if (pd.slice(-3) == "USD") {
        pd += "T"
    }
    //////console.log(pd);
   
    try {
        var p;
        if (pair == "BTC/USDT") {
            p = 'btc_usdt';
        } else {
            p = pair


        }
        
    } catch (err) { 
console.log(err); gogo['okexTrades'] = true;
    }

    try {

        if (pair.slice(-4) == "USDT") {
            var p = pair.substr(0, pair.length - 1).split('/')[0];
        } else {
            var p = pair.split('/')[0];
        }
 
            if (keys2.includes('t' + p)){
        ws2.subscribeTicker("t" + p)
    }


    } catch (err) {
        gogo['bitfinexTrades'] = true;
    }
}
ws2.onTicker({}, (ticker) => {
    var p = ticker.symbol.substr(1, ticker.symbol.length)
    if (p.slice(-3) == 'USD') {
        p += "T"
    }
    if (asks[p] == undefined) {
        asks[p] = []
        bids[p] = []
    }
    asks[p]['bitfinex'] = ticker.ask
    bids[p]['bitfinex'] = ticker.bid
    gogo['bitfinexTrades'] = true;

})
ws2.open()
var done = []

setInterval(function(){
      doSharpe();

}, 60 * 1000);

async function doSharpe(){
    rdiffs.push(rdiff)
      retdiffs.push(retdiff)
      if (rdiffs.length > 100){
        rdiffs.shift();
        retdiffs.shift();
      }
    ////console.log(rdiff)
      // Build the equity curves corresponding to the returns
      returnPortfolio = new Array(retdiffs.length +1);
      benchmark = new Array(rdiffs.length +1 );
      zeroRisk = new Array(rdiffs.length +1);

        returnPortfolio[0] = retdiffs[0];
        benchmark[0] = rdiffs[0];
        zeroRisk[0] = rdiffs[0];
      for (var i=0; i<retdiffs.length; ++i) {
        returnPortfolio[i+1] = returnPortfolio[i] * (1 + retdiffs[i]);
        benchmark[i+1] = benchmark[i] * (1 + rdiffs[i]);
        zeroRisk[i+1] = zeroRisk[i];
      }
      sharpe = PortfolioAnalytics.sharpeRatio(returnPortfolio, benchmark)
      ////console.log('sharpe: ' + sharpe)
}
setTimeout(function(){
    doSharpe();
}, 20000)

setTimeout(function(){
    doSharpe();
}, 24000)



app.get('/update', (req, res) => {

    doPost(req, res)

})

app.get('/', (req, res) => {
    doPost(req, res)

})
app.post('/', (req, res) => {
    doPost(req, res)

})
let maxbal = 50;
let total2 = 0;
let bnbtotal = 0;
let btctotal = 0;
let trades2 = []
let tradeids = []
let tradedBalsPlus = {}
let tradedBalsMinus = {}
let totalbefore = 0;

let thebooks = {}
async function books(){
    let gos = {}
        let avgs = {}
        for (var v in vols) {
            avgs[v] = vols[v] / cs[v];
        }
        for (var a in avgs) {
            if (a != 'USDS') {
                for (var t in tickVols) {

                    if (t.substring(t.length - 3, t.length) == a) {
                        if (tickVols[t] > avgs[a] / targetVolDiv && tickVols[t] < avgs[a] * targetVolMult && spreads[t] > targetSpread) {
                            if (gos[a] == undefined) {
                                gos[a] = {}
                            }
                            gos[a][(t)] = tickVols[t];
                        }
                    } else if (t.substring(t.length - 4, t.length) == a) {
                        if (tickVols[t] > avgs[a] / targetVolDiv && tickVols[t] < avgs[a] * targetVolMult && spreads[t] > targetSpread) {
                            if (gos[a] == undefined) {
                                gos[a] = {}
                            }
                            gos[a][(t)] = tickVols[t];
                        }
                    }

                }
            }
        }
        
        for (var g in gos){

            for (var symbol in gos[g]){
                client.ws.partialDepth({ symbol: symbol, level: 20 }, depth => {
                  thebooks[depth.symbol] = {asks: depth.asks, bids: depth.bids}
                })
            }
        }
}
let starttime2 = new Date().getTime() - 24 * 60 * 60 * 1000;
setInterval(function(){
    books()
}, 30000)
let ts = {}
async function getTrades(){
    let gos = {}
        let avgs = {}
         tradedBalsPlus = {}

                        tradedBalsMinus = {}
        for (var v in vols) {
            avgs[v] = vols[v] / cs[v];
        }
        for (var a in avgs) {
            if (a != 'USDS') {
                for (var t in tickVols) {

                    if (t.substring(t.length - 3, t.length) == a) {
                        if (tickVols[t] > avgs[a] / targetVolDiv && tickVols[t] < avgs[a] * targetVolMult && spreads[t] > targetSpread) {
                            if (gos[a] == undefined) {
                                gos[a] = {}
                            }
                            gos[a][(t)] = tickVols[t];
                        }
                    } else if (t.substring(t.length - 4, t.length) == a) {
                        if (tickVols[t] > avgs[a] / targetVolDiv && tickVols[t] < avgs[a] * targetVolMult && spreads[t] > targetSpread) {
                            if (gos[a] == undefined) {
                                gos[a] = {}
                            }
                            gos[a][(t)] = tickVols[t];
                        }
                    }

                }
            }
        }
        
        for (var g in gos){

            for (var symbol in gos[g]){
        let trades = (await client.myTrades({
          symbol: symbol,
        }))
        ts[symbol]=(trades)
        for (var t in trades){

            if (!tradeids.includes(trades[t].id + trades[t].time )&&  parseFloat(trades[t].time) > starttime2){
                //////console.log(trades[t])
                
                tradeids.push(trades[t].id + trades[t].time);
            trades2.push({'symbol': symbol, 'price': trades[t].price, 'isBuyer': trades[t].isBuyer, 'time': trades[t].time})

            if (trades[t].symbol != 'ETHBTC' && trades[t].symbol != 'USDBTC' && trades[t].symbol != 'BTCUSD'){
            if (trades[t].symbol.substring(trades[t].symbol.length - 4, trades[t].symbol.length).startsWith('USD') || trades[t].symbol.substring(trades[t].symbol.length - 3, trades[t].symbol.length).startsWith('USD')){
                btcVol += parseFloat(trades[t].quoteQty)* btcs['USD']
            }
            else  if (trades[t].symbol.substring(trades[t].symbol.length - 3, trades[t].symbol.length) == 'ETH'){
                btcVol += parseFloat(trades[t].quoteQty)* btcs['ETH']
            }
            else if (trades[t].symbol.substring(trades[t].symbol.length - 3, trades[t].symbol.length) == 'BTC'){
             
                btcVol += ((parseFloat(trades[t].quoteQty)))
            }
            else if (trades[t].symbol.substring(trades[t].symbol.length - 3, trades[t].symbol.length) == 'BNB'){
                btcVol += (((parseFloat(trades[t].quoteQty) * btcs['BNB'])))
            }
      
        }
        if (trades[t].time > starttime2){
                if (trades[t].isBuyer){
                    if (tradedBalsPlus[trades[t].symbol]  == undefined){
                        tradedBalsPlus[trades[t].symbol] = {price: [], qty: []}
                    }
                    tradedBalsPlus[trades[t].symbol].price.push(parseFloat(trades[t].price))
                    tradedBalsPlus[trades[t].symbol].qty.push(parseFloat(trades[t].qty))
                    

                }
                else {
                    renew[symbol] = true;
                    changed[symbol] = true;
                    if (tradedBalsMinus[trades[t].symbol] == undefined){
                        tradedBalsPlus[trades[t].symbol] = {price: [], qty: []}

                        tradedBalsMinus[trades[t].symbol] = {price: [], qty: []}
                    }
                    tradedBalsMinus[trades[t].symbol].price.push(parseFloat(trades[t].price))
                    //tradedBalsPlus[trades[t].symbol].qty.push(-1*parseFloat(trades[t].qty))
                    //tradedBalsPlus[trades[t].symbol].price.push(parseFloat(trades[t].price))
                    tradedBalsMinus[trades[t].symbol].qty.push(parseFloat(trades[t].qty))
                }
        }
        }
        }

    }

}

let doSyms = []

for (var t in ts){

            if (!doSyms.includes(t)){
                console.log(t)
                doSyms.push(t)
            }
        }
        for (var symbol in doSyms){
                let upperprice = 0;
                let lowerprice = 999999999999999999999999999;
                let qty = 0;
            let qty2 = 0
                let lp;
                try {
                for (var buy in tradedBalsPlus[doSyms[symbol]].price){
                if (tradedBalsPlus[doSyms[symbol]].price[buy] > upperprice){
                    if (tradedBalsPlus[doSyms[symbol]].qty[buy] > 0){
                    upperprice=tradedBalsPlus[doSyms[symbol]].price[buy];
                }
                }
                if (tradedBalsPlus[doSyms[symbol]].price[buy] < lowerprice){
                    if (tradedBalsPlus[doSyms[symbol]].qty[buy] > 0){

                    lowerprice = tradedBalsPlus[doSyms[symbol]].price[buy]
                }
                    lp = buy;
                }
}
                for (var qtys in tradedBalsPlus[doSyms[symbol]].qty){
                    qty += tradedBalsPlus[doSyms[symbol]].qty[qtys]
                }
                for (var qtys in tradedBalsMinus[doSyms[symbol]].qty){
                    qty2 += tradedBalsMinus[doSyms[symbol]].qty[qtys]
                }
                let diff = (upperprice - lowerprice) ;
                let diff2 = diff * qty / qty2
                let diff3 = upperprice - diff2 
                if (diff != upperprice){
            console.log(doSyms[symbol] + ' buyo update!')
             console.log(buyOs[doSyms[symbol] ])
             if (usddiff < 0){
                buyOs[doSyms[symbol]] = diff3  * (1-(usddiff/100/(gocount / 4)));
            }
            else {
                buyOs[doSyms[symbol]] = diff3  * 1.002;
            }
             console.log(buyOs[doSyms[symbol] ])
     
     }
    }catch(err){
        console.log(err);
    }
        }

}
let buyOrders = 0;
let sellOrders = 0;
let numOrders = 0;
let btcVol = 0;
setInterval(function(){
    getTrades()
}, 65 * 1001)
let usddiff;
async function doPost(req, res) {

        let gos = {}
        let avgs = {}
        for (var v in vols) {
            avgs[v] = vols[v] / cs[v];
        }
        for (var a in avgs) {
            if (a != 'USDS') {
                for (var t in tickVols) {

                    renew[t] = true;
                    if (t.substring(t.length - 3, t.length) == a) {
                        if (tickVols[t] > avgs[a] / targetVolDiv && tickVols[t] < avgs[a] * targetVolMult && spreads[t] > targetSpread) {
                            if (gos[a] == undefined) {
                                gos[a] = {}
                            }
                            gos[a][(t)] = tickVols[t];
                        }
                    } else if (t.substring(t.length - 4, t.length) == a) {
                        if (tickVols[t] > avgs[a] / targetVolDiv && tickVols[t] < avgs[a] * targetVolMult && spreads[t] > targetSpread) {
                            if (gos[a] == undefined) {
                                gos[a] = {}
                            }
                            gos[a][(t)] = tickVols[t];
                        }
                    }

                }
            }
        }
    let buyOrders = 0;
    let sellOrders = 0;
        for (var g in gos){
            for (var symbol in gos[g]){
     let orders2 = (await client.openOrders({
        symbol: symbol,
    }))
    numOrders = orders2.length
    for (var o in orders2){
        if (orders2[o].side == 'BUY'){
            buyOrders++;
        }
        else {
            sellOrders++;
        }
    }
    }
}
     numOrders = buyOrders + sellOrders;
    total2 = 0;
    //let bals = balscombined
    total2 = 0;
    bnbtotal = 0;
    btctotal = 0;
    //////console.log(bals)
    for (var bal in bals){
                    // ////console.log(parseFloat(bals[bal]))
                    if (bals[bal] > 0.00001 && btcs[bal] > 0 || btcs2[bal] > 0){
                 if (bal.startsWith('USD')){
                    total2 += parseFloat(bals[bal])
                }
                else if (bal == 'BTC'){
                    total2 += parseFloat(bals[bal]) * parseFloat(btcs[bal])
                }
                else if (bal == 'ETH'){

                    total2 += parseFloat(bals[bal]) * parseFloat(btcs2[bal])

                } else if (bal == 'BNB'){
                    total2 += parseFloat(bals[bal]) * parseFloat(btcs2[bal])

                } else {
                   // //console.log(bal + ': ' + parseFloat(bals[bal]) * parseFloat(btcs2[bal]))
                    total2 += parseFloat(bals[bal]) * parseFloat(btcs2[bal])
                }
               }
    
    }
    //console.log('total2 before: ' + total2)
    
        if (true){
            let refdiff = 100* (-1 * (1 - (btcs['BTC'] / btcref)));
    usddiff = 100* (-1 * (1 - (total2 / usdstart)));
    btctotal = (((total2 / btcs['BTC'])));
    bnbtotal = (((total2 / btcs2['BNB'])));
    let btcdiff = 100* (-1 * (1 - (btctotal / btcstart)));
    let bnbdiff = 100* (-1 * (1 - (bnbtotal / bnbstart)));
    rdiff = refdiff;
    let adiff = [usddiff, btcdiff, bnbdiff]
    let lll = -9999999999999999999999999999
    for (var a in adiff){
        if (adiff[a] > lll){
            lll = adiff[a]
        }
    }
    retdiff = lll;
    totalbefore = total2;
    /*
    for (var t in feesusd){

        bals[t.substring(0, t.length-3)] += feesusd[t]
    }
    for (var t in feesbtc){

        bals[t.substring(0, t.length-3)] += feesbtc[t]
    }
    for (var t in feeseth){

        bals[t.substring(0, t.length-3)] += feeseth[t]
    }*/
    let total22 = 0;
   let bnbtotal2 = 0;
  let  btctotal2 = 0;
    //////console.log(bals)
    for (var bal in bals){
                    // ////console.log(parseFloat(bals[bal]))
                    if (bals[bal] > 0.00001){
                 if (bal == 'USD'){
                    total22 += parseFloat(bals[bal])
                }
                else if (bal == 'BTC'){

                    total22 += parseFloat(bals[bal]) * parseFloat(btcs[bal])
                }
                else if (bal == 'ETH'){
                    total22 += parseFloat(bals[bal]) * parseFloat(btcs2[bal])

                } else {
                    total22 += parseFloat(bals[bal]) * parseFloat(btcs2[bal])
                }
               }
    
    }

    let refdiff2= 100* (-1 * (1 - (btcs['BTC'] / btcref)));
    btctotal2 = (((total22 / btcs['BTC'])));
    btctotal2 = btctotal2 + (btcVol * 0.0008)
    total22 = btctotal2 * btcs['BTC']
    bnbtotal2 = (((total22 / btcs2['BNB'])));
    usddiff2 = 100* (-1 * (1 - (total22 / usdstart)));
    let btcdiff2 = 100* (-1 * (1 - (btctotal2 / btcstart)));
    let bnbdiff2 = 100* (-1 * (1 - (bnbtotal2 / bnbstart)));
    let rdiff2 = refdiff2;
    let adiff2 = [usddiff2, btcdiff2, bnbdiff2]
    let lll2 = -9999999999999999999999999999
    for (var a in adiff2){
        if (adiff2[a] > lll2){
            lll2 = adiff2[a]
        }
    }
    rdiff = refdiff;
    retdiff = lll2;
    //console.log('total2 after: ' + total22)
    if (req.query.name) {
        res.json({
            usddiff: usddiff,
            btcdiff: btcdiff,
            bnbdiff: bnbdiff,
            total: total2,
            btc: btctotal,
            bnb: bnbtotal,
            usddiff2: usddiff2,
            btcdiff2: btcdiff2,
            bnbdiff2: bnbdiff2,
            total2: total22,
            btc: btctotal,
            bnb: bnbtotal,
            btc2: btctotal2,
            bnb2: bnbtotal2,
            trades2: trades2,
            trades: trades2.length,
            orders: numOrders,
            buyOrders: buyOrders,
            sellOrders: sellOrders,
            balances: bals3,
            balances2 : bals4,
            bids: avgBids,
            stops: stopp,
            buyOs: buyOs,
            divisor: divisor,
            btcVol: btcVol,
            least: starttime2,
            refdiff: refdiff,
            refdiff2: refdiff2,
            sharpe: sharpe,
            msg: msg,
            url: process.env.url || "techvoices.club"
        });

    } else {
        res.render('binance.ejs', {
            name: "",
            json: {},
            avgAsk: {},
            msg: "",
            trades: [],
            url: process.env.url || "techvoices.club"
        })
    }
}
    total2 = 0;
}
let ticks = []
let bases = []
let vols = {}
let cs = {}
let tickVols = {}
let spreads = {}
let btcs = {}
let btcs2 = {}
client.ws.allTickers(tickers => {
    for (var t in tickers) {
            if (tickers[t].symbol == 'ETHBTC') {
                btcs['ETH'] = tickers[t].bestBid;
            }
            else if (tickers[t].symbol == 'BNBBTC') {
                btcs['BNB'] = tickers[t].bestBid;
            }
        let symbol = tickers[t].symbol;
        let asset;
        if (symbol.substring(symbol.length - 3, symbol.length) == 'BTC') {

            asset = symbol.substring(0, symbol.length - 3)


        if (asset != 'ETH' && asset != 'BTC' && asset != 'USD' && asset != 'BNB'){
            btcs[asset] = parseFloat(tickers[t].bestBid)
        }

        }

        if (tickers[t].symbol == 'BTCUSDT') {

            for (b in btcs) {
                btcs2[b] = btcs[b] * tickers[t].bestBid;
            }
            btcs2['BNB'] = parseFloat(tickers[t].bestBid) * btcs['BNB'];
            btcs2['ETH'] = parseFloat(tickers[t].bestBid) * btcs['ETH'];
            btcs['BTC'] = parseFloat(tickers[t].bestBid);
        }
        let spread = (100 * (1 - parseFloat(tickers[t].bestBid) / parseFloat(tickers[t].bestAsk)))
        if (!ticks.includes(tickers[t].symbol) && spread) {
            spreads[tickers[t].symbol] = spread;
            tickVols[tickers[t].symbol] = (parseFloat(tickers[t].volumeQuote))
            if (tickers[t].symbol.substring(tickers[t].symbol.length - 4, tickers[t].symbol.length).includes('USD')) {
                if (!bases.includes(tickers[t].symbol.substring(tickers[t].symbol.length - 4, tickers[t].symbol.length))) {
                    bases.push(tickers[t].symbol.substring(tickers[t].symbol.length - 4, tickers[t].symbol.length))
                }
            } else {
                if (!bases.includes(tickers[t].symbol.substring(tickers[t].symbol.length - 3, tickers[t].symbol.length))) {
                    bases.push(tickers[t].symbol.substring(tickers[t].symbol.length - 3, tickers[t].symbol.length))
                }
            }
            ticks.push(tickers[t].symbol)
            for (var t in tickers) {
                for (b in bases) {
                    if (vols[bases[b]] == undefined) {
                        vols[bases[b]] = 0;
                        cs[bases[b]] = 0;
                    }
                    if (tickers[t].symbol.substring(tickers[t].symbol.length - 4, tickers[t].symbol.length) == bases[b]) {
                        vols[bases[b]] += (parseFloat(tickers[t].volumeQuote));
                        cs[bases[b]]++;
                    } else if (tickers[t].symbol.substring(tickers[t].symbol.length - 3, tickers[t].symbol.length) == bases[b]) {
                        vols[bases[b]] += (parseFloat(tickers[t].volumeQuote));
                        cs[bases[b]]++;
                    }
                }

            }

        }
    }
})
let rego = true;
setInterval(function(){
rego = true;
}, 30000)
async function doBal(){

    if (rego){
        bals = {}
        bals3 = {}
        bals4 = {}
        balscombined = {}
        rego = false;
        let balances = (await client.accountInfo()).balances
        for (var b in balances) {
        if (balances[b].free > 0 || balances[b].locked > 0){
        bals3[balances[b].asset] = parseFloat(balances[b].free)
        bals4[balances[b].asset] = parseFloat(balances[b].locked)
        balscombined[balances[b].asset] = parseFloat(balances[b].free) + parseFloat(balances[b].locked)  
        bals[balances[b].asset] = parseFloat(balances[b].free) + parseFloat(balances[b].locked)  
          }
}
//console.log('etheth');
//console.log(balscombined['ETH'])
    }
}
setInterval(function(){

doBal();
}, 31000)
client.ws.user(msg => {
  let balances = (msg.balances)
  for (var b in balances) {
        if (balances[b].free > 0 || balances[b].locked > 0){
        bals3[balances[b].asset] = parseFloat(balances[b].free)
        bals4[balances[b].asset] = parseFloat(balances[b].locked)
        balscombined[balances[b].asset] = parseFloat(balances[b].free) + parseFloat(balances[b].locked) 
        bals[balances[b].asset] = parseFloat(balances[b].free) + parseFloat(balances[b].locked)  
           }
}
//console.log(balscombined)
})
askOrders = {}
bidOrders = {}
let notabuys = []
let count = 1;
let lala = 0;
let selling = {}
let precisions = {}
let filters = {}
async function cancelAll() {


buys = []
sells = []
las = {}
hbs = {}
aorders = {}
borders = {}
buyQtys = {}
lalesss = {}
hblesss = {}

vols = {}
cs = {}
tickVols = {}
spreads = {}
//btcs = {}
//btcs2 = {}
                renew = {}
                changed = {}
                tradedBalsPlus = {}
                tradedBalsMinus = {}
                thebooks = {}
    try {
        let gos = {}
        let avgs = {}
        for (var v in vols) {
            avgs[v] = vols[v] / cs[v];
        }
        for (var a in avgs) {
            if (a != 'USDS') {
                for (var t in tickVols) {

                    renew[t] = true;
                    if (t.substring(t.length - 3, t.length) == a) {
                        if (tickVols[t] > avgs[a] / targetVolDiv && tickVols[t] < avgs[a] * targetVolMult && spreads[t] > targetSpread) {
                            if (gos[a] == undefined) {
                                gos[a] = {}
                            }
                            gos[a][(t)] = tickVols[t];
                        }
                    } else if (t.substring(t.length - 4, t.length) == a) {
                        if (tickVols[t] > avgs[a] / targetVolDiv && tickVols[t] < avgs[a] * targetVolMult && spreads[t] > targetSpread) {
                            if (gos[a] == undefined) {
                                gos[a] = {}
                            }
                            gos[a][(t)] = tickVols[t];
                        }
                    }

                }
            }
        }
        let dont = []
        for (var sym in ticks) {

            for (var g in gos) {
                for (var symbol in gos[g]) {
                                        asset = symbol.substring(0, symbol.length - 3)

                    if (asset != 'USD' && asset != 'BTC' && asset != 'USDU'){
                    if (symbol == sym) {
                        dont.push(symbol)
                    }
                }
            }
            }
        }
        //bals = balscombined;
        for (var sym in ticks) {
	    //let bal = symbol.substring(0, symbol.length - 3)
            let book;
if (true){
//            if (bal != 'BTC' && bal != 'USDS' && bal != 'ETH' && bal != 'BNB' && bals[bal] != 0) {
                if (!dont.includes(sym)) {
//                    let symbol = bal + 'BNB';
                    

try {
                        let orders = (await client.openOrders({
                            symbol: sym,
                        }))

                        for (var o in orders) {
                            ////console.log(orders[o])
                            ////console.log('cancel')

                            (await client.cancelOrder({
                                symbol: symbol,
                                orderId: orders[o].orderId,
                                }))
}
} catch (err) {
}
/*
try {
                                symbol = bal + 'ETH';
                        

                        
                            let orders = (await client.openOrders({
                                symbol: symbol,
                            }))

                            for (var o in orders) {
                                ////console.log(orders[o])
                                ////console.log('cancel')
                                (await client.cancelOrder({
                                    symbol: symbol,
                                    orderId: orders[o].orderId,
                                }))
                            }
} catch (err) {

console.log(err);
}
try {
                                symbol = bal + 'BTC';
                        

                        
                            let orders = (await client.openOrders({
                                symbol: symbol,
                            }))

                            for (var o in orders) {
                                ////console.log(orders[o])
                                ////console.log('cancel')
                                (await client.cancelOrder({
                                    symbol: symbol,
                                    orderId: orders[o].orderId,
                                }))
                            }
} catch (err) {}
 */                                   }
            }
        }
    } catch (err) {
        console.log(err);
    }
}
setInterval(function() {
    cancelAll();
}, 60 * 1000 * 5)
async function exchangeinfo(){
let exchange = (await client.exchangeInfo())
        for (var symbol in exchange.symbols) {
            precisions[exchange.symbols[symbol].symbol] = {
                'base': exchange.symbols[symbol].baseAsset,
                'quote': exchange.symbols[symbol].quoteAsset,
                'bp': exchange.symbols[symbol].baseAssetPrecision,
                'qp': exchange.symbols[symbol].quotePrecision
            }
            filters[exchange.symbols[symbol].symbol] = {
                'minPrice': parseFloat(exchange.symbols[symbol].filters[0].minPrice),
                'minQty': parseFloat(exchange.symbols[symbol].filters[2].minQty),
                'tickSize': countDecimalPlaces(parseFloat(exchange.symbols[symbol].filters[0].tickSize)),
                'stepSize': countDecimalPlaces(parseFloat(exchange.symbols[symbol].filters[2].stepSize)),
                'minNotional': parseFloat(exchange.symbols[symbol].filters[3].minNotional)
            }
        }
        }
exchangeinfo()
async function doit() {
    notabuys = []
    try {
        
        //bals = balscombined
        let gos = {}
        let avgs = {}
        for (var v in vols) {
            avgs[v] = vols[v] / cs[v];
        }
        for (var a in avgs) {
            if (a != 'USDS') {
                for (var t in tickVols) {

                    if (t.substring(t.length - 3, t.length) == a) {
                        if (tickVols[t] > avgs[a] / targetVolDiv && tickVols[t] < avgs[a] * targetVolMult && spreads[t] > targetSpread) {
                            if (gos[a] == undefined) {
                                gos[a] = {}
                            }
                            gos[a][(t)] = tickVols[t];
                        }
                    } else if (t.substring(t.length - 4, t.length) == a) {
                        if (tickVols[t] > avgs[a] / targetVolDiv && tickVols[t] < avgs[a] * targetVolMult && spreads[t] > targetSpread) {
                            if (gos[a] == undefined) {
                                gos[a] = {}
                            }
                            gos[a][(t)] = tickVols[t];
                        }
                    }

                }
            }
        }
        //console.log(gos);
        let dont = []
        for (var sym in ticks) {

            for (var g in gos) {
                for (var symbol in gos[g]) {
                    if (symbol == sym) {
                        dont.push(symbol)
                    }
                }
            }
        }

        for (var symbol in stopp) {
            if (true) {
                //////console.log('2 ' + symbol)
                //testing
                //////console.log(symbol)
                if (true) { //if (symbol == "GNTBNB"){
                     let book = thebooks[symbol]
                    let hb = 0;
                    let hbless = 0;
                    let laless = 0;
                    for (var bid in book.bids) {
                        if (parseFloat(book.bids[bid].price) > hb) {
                            hbless = hb;
                            hb = parseFloat(book.bids[bid].price);
                        }
                    }
                    let la = 50000000000000000000000;
                    for (var ask in book.asks) {
                        if (parseFloat(book.asks[ask].price) < la) {
                            laless = la;
                            la = parseFloat(book.asks[ask].price)
                        }
                    }

        //bals = balscombined
                            asset = symbol.substring(0, symbol.length - 3)

                        //////console.log('asset: ' + asset)

                        if (true) {
                            if (lala == 0) {
                                ////////console.log(precisions[symbol]);
                                ////////console.log(filters[symbol])
                                ////////console.log((bals[symbol.substring(symbol.length - 3, symbol.length)] / (hb * 1.0001)).toFixed(filters[symbol].stepSize - 1));
                                  bp = (hb * 1.0001)
                                bp = bp.toFixed(filters[symbol].tickSize - 1)
                                sp = (la * .995)
                                sp = sp.toFixed(filters[symbol].tickSize - 1)
                                    //////console.log('sp: ' + sp)
                                buyQty = ((bals[symbol.substring(symbol.length - 3, symbol.length)] / (hb * 1.0001) / (Object.keys(gos[g]).length / 4)).toFixed(filters[symbol].stepSize - 1));
                                let dontgo = false;
                                let sellQty = (parseFloat(bals[asset]) * 0.995).toFixed(filters[symbol].stepSize - 1)
                                sellQty = sellQty * 1000
                                //////console.log(sellQty)
                                //////console.log(filters[symbol].minNotional)
                                if ((sellQty) * hb * 1.0001 < filters[symbol].minNotional) {
                                    console.log('dontgo minnotional ' + symbol)
                                    dontgo = true;
                                }
                                if (sellQty < filters[symbol].minQty) {

                                    console.log('dontgo minqty ' + symbol)
                                    dontgo = true;
                                }
                                
                                if (sp < stopp[symbol]) {
                    let orders = (await client.openOrders({
                            symbol: symbol,
                        }))

                       for (var o in orders) {
                                if (orders[o].side == 'SELL'){
                                ////console.log(orders[o])
                                ////console.log('cancel')
                                (await client.cancelOrder({
                                    symbol: symbol,
                                    orderId: orders[o].orderId,
                                }))


                            }
                        }
                                                                    stopp[symbol] = 0;
                                dontbuy[symbol] = false;

                                    //lala++;
                                    try {
                                        /* buys.push(await client.order({
                  symbol: symbol,
                  side: 'buy',
                  quantity: buyQty,
                  price: bp,
                })) */
                //////console.log('\sellQty: ' + sellQty)
                                        (await client.order({
                                            symbol: symbol,
                                            side: 'SELL',
                                            quantity: sellQty,
                                            type: 'MARKET'
                                        }))
                                        /*//console.log({
                                            symbol: symbol,
                                            side: 'sell',
                                            quantity: Number(sellQty),
                                                price: Number(sp)
                                        })*/
                                        //////console.log(order)
                                        //////console.log(buys);
                                        //////console.log(sells);
                                    } catch (err) {

                                        console.log(err);
                                    }
                                    las[symbol] = la;
                                    hbs[symbol] = hb;
                                }

                            }

                        }
                    
                    /*

                     */
                }
            }
        }
        gocount = 0;
        for (var g in gos) {
            for (var symbol in gos[g]) {
                gocount++;
                if (g != 'PAX' && g != 'USDC' && g != 'XRP'){
                //console.log('sell1 ' + symbol)
                //testing
                ////console.log(symbol)
                //console.log(g)
                try { //if (symbol == "GNTBNB"){
                    let book = thebooks[symbol]
                    let hb = 0;
                    let hbless = 0;
                    let laless = 0;
                    for (var bid in book.bids) {
                        if (parseFloat(book.bids[bid].price) > hb) {
                            hbless = hb;
                            hb = parseFloat(book.bids[bid].price);
                        }
                    }
                    let la = 50000000000000000000000;
                    for (var ask in book.asks) {
                        if (parseFloat(book.asks[ask].price) < la) {
                            laless = la;
                            la = parseFloat(book.asks[ask].price)
                        }
                    }
                    //console.log('sell1: ' + symbol + ' la: ' + la + ' hb: ' + hb)
                    if (symbol != 'BNBUSDS' && (hblesss[symbol] != hbless || lalesss[symbol] != laless) || (las[symbol] != la && hbs[symbol] != hb)) {
                        hblesss[symbol] = hbless
                        lalesss[symbol] = laless
                        
                        //bals = balscombined
                        if (symbol.substring(symbol.length - 4, symbol.length) == g) {

                            asset = symbol.substring(0, symbol.length - 4)
                        } else {
                            asset = symbol.substring(0, symbol.length - 3)


                        }
                        //console.log('sell1 asset: ' + asset)

                        if (bals[asset] != 0) {
                            if (lala == 0) {
                                //////console.log(precisions[symbol]);
                                //////console.log(filters[symbol])
                                //////console.log((bals[symbol.substring(symbol.length - 3, symbol.length)] / (hb * 1.0001)).toFixed(filters[symbol].stepSize - 1));
                                bp = (hb * 1.0001)
                                bp = bp.toFixed(filters[symbol].tickSize - 1)
                                sp = (la * .995)
                                sp = sp.toFixed(filters[symbol].tickSize - 1)
                                buyQty = ((bals[symbol.substring(symbol.length - 3, symbol.length)] / (hb * 1.0001) / Object.keys(gos[g]).length).toFixed(filters[symbol].stepSize - 1));
                                let dontgo = false;
                                let sellQty = (parseFloat(bals[asset]) * 0.995).toFixed(filters[symbol].stepSize - 1)
                                ////console.log(sellQty)
                                ////console.log(filters[symbol].minNotional)
                                if ((sellQty) * hb * 1.0001 < filters[symbol].minNotional) {
                                    ////console.log('dontgo minnotional ' + symbol)
                                    dontgo = true;
                                }
                                if (sellQty < filters[symbol].minQty) {

                                    ////console.log('dontgo minqty ' + symbol)
                                    dontgo = true;
                                }
                                //////console.log(bp)
                                
                                if ((neversellataloss == true && ((sp < buyOs[symbol])))){
                                    //dontbuy[symbol] = true;
                                }
                                if ((sellQty > 0.0000000001) && dontgo == false && (neversellataloss == true && (sp > buyOs[symbol] || buyOs[symbol] == undefined))) {
let orders = (await client.openOrders({
                            symbol: symbol,
                        }))

                        for (var o in orders) {
                                if (orders[o].side == 'SELL'){
                                ////console.log(orders[o])
                                ////console.log('cancel')
                                (await client.cancelOrder({
                                    symbol: symbol,
                                    orderId: orders[o].orderId,
                                }))


                            }
                        }
                                    //lala++;
                                    try {
                                        /* buys.push(await client.order({
                  symbol: symbol,
                  side: 'BUY',
                  quantity: buyQty,
                  price: bp,
                })) */			/*console.log({
                                            symbol: symbol,
                                            side: 'SELL',
                                            quantity: sellQty,
                                            price: sp,
                                        })*/
                                        (await client.order({
                                            symbol: symbol,
                                            side: 'SELL',
                                            quantity: sellQty,
                                            price: sp,
                                        }))
                                        ////console.log(buys);
                                        ////console.log(sells);
                                    } catch (err) {

                                        console.log(err);
                                    }
                                    las[symbol] = la;
                                    hbs[symbol] = hb;
                                }

                            }

                        }
                    }
                    /*

                     */
                }
                catch (err){

                }
            }
            }
        }
        ////console.log('wololo')
        //bals = balscombined

        for (var bal in bals) {
            let book;
            if (bal != 'BTC' && bal != 'USDS' && bal != 'ETH' && bal != 'BNB' && bals[bal] != 0) {
                if (bals[bal] != 0 && !dont.includes(symbol)) {
                    let symbol = bal + 'ETH';
client.ws.partialDepth({ symbol: symbol, level: 20 }, depth => {
                  thebooks[depth.symbol] = {asks: depth.asks, bids: depth.bids}
                })

                    console.log(symbol)
                    if (true) {
                        console.log(bal)
                        try {
                            book = thebooks[symbol]
                        } catch (err) {
                            symbol = bal + 'BTC';
                            ////console.log(symbol)
                            try {
                            //    book = thebooks[symbol]
                            } catch (err) {
                                symbol = bal + 'BNB';
                                ////console.log(symbol)
                              //  book = thebooks[symbol]
                            }
                        }
                    }
                    console.log(dont);
                    if (true) {
                        try {
                        let hb = 0;
                        let hbless = 0;
                        let laless = 0;
                        for (var bid in book.bids) {
                            if (parseFloat(book.bids[bid].price) > hb) {
                                hbless = hb;
                                hb = parseFloat(book.bids[bid].price);
                            }
                        }
                        let la = 50000000000000000000000;
                        for (var ask in book.asks) {
                            if (parseFloat(book.asks[ask].price) < la) {
                                laless = la;
                                la = parseFloat(book.asks[ask].price)
                            }
                        }
                        console.log('sell2: ' + symbol + ' la: ' + la + ' hb: ' + hb)
          //            if (symbol != 'BNBUSDS' && (selling[symbol] == false) || ((hblesss[symbol] != hbless || lalesss[symbol] != laless) || (las[symbol] != la && hbs[symbol] != hb))) {
if (true){              
              selling[symbol] = true;
                        //if (symbol != 'BNBUSDS' && (selling[symbol] == false) || ((hblesss[symbol] != hbless || lalesss[symbol] != laless) || (las[symbol] != la && hbs[symbol] != hb))) {
                    
                            hblesss[symbol] = hbless
                            lalesss[symbol] = laless
                            
                            //bals = balscombined
                            if (symbol.substring(symbol.length - 4, symbol.length) == g) {

                                asset = symbol.substring(0, symbol.length - 4)
                            } else {
                                asset = symbol.substring(0, symbol.length - 3)


                            }
asset = bal;
                            console.log('asset sell2: ' + asset)

                            if (true) {
                                if (true) {
                                    //////console.log(precisions[symbol]);
                                    //////console.log(filters[symbol])
                                    //////console.log((bals[symbol.substring(symbol.length - 3, symbol.length)] / (hb * 1.0001)).toFixed(filters[symbol].stepSize - 1));
                                    bp = (hb * 1.0001)
                                    bp = bp.toFixed(filters[symbol].tickSize - 1)
                                    sp = (la * .995)
                                    sp = sp.toFixed(filters[symbol].tickSize - 1)
                                    buyQty = ((bals[symbol.substring(symbol.length - 3, symbol.length)] / (hb * 1.0001) / Object.keys(gos[g]).length).toFixed(filters[symbol].stepSize - 1));
                                    let dontgo = false;
                                    let sellQty = (parseFloat(bals[asset]) * 0.995).toFixed(filters[symbol].stepSize - 1)
                                    console.log(sellQty)
                                    ////console.log(filters[symbol].minNotional)
                                    if ((sellQty) * hb * 1.0001 < filters[symbol].minNotional) {
                                        console.log('dontgo minnotional ' + symbol)
                                        dontgo = true;
                                    }
                                    if (sellQty < filters[symbol].minQty) {

                                        console.log('dontgo minqty ' + symbol)
                                        dontgo = true;
                                    }
                                    //////console.log(buyQty)
                                    //////console.log(bp)
                                    
                                if ((neversellataloss == true && ((sp < buyOs[symbol])))){
                                    //dontbuy[symbol] = true;
                                }
console.log('sellqty: ' + sellQty + ': ' + symbol);
                                    if ((sellQty > 0.00000000000000001) && dontgo == false && (neversellataloss == true && (sp > buyOs[symbol] || buyOs[symbol] == undefined))) {
let orders = (await client.openOrders({
                                symbol: symbol,
                            }))

                            for (var o in orders) {
                                if (orders[o].side == 'SELL'){
                                ////console.log(orders[o])
                                ////console.log('cancel')
                                (await client.cancelOrder({
                                    symbol: symbol,
                                    orderId: orders[o].orderId,
                                }))


                            }
                        }
                                        //lala++;
                                        try {
                                            /* buys.push(await client.order({
                  symbol: symbol,
                  side: 'BUY',
                  quantity: buyQty,
                  price: bp,
                })) */

                                            las[symbol] = la;
                                            hbs[symbol] = hb;
console.log({
                                                symbol: symbol,
                                                side: 'SELL',
                                                quantity: sellQty,
                                                price: sp,
                                            })
                                           // notabuys.push(symbol)
                                            (await client.order({
                                                symbol: symbol,
                                                side: 'SELL',
                                                quantity: sellQty,
                                                price: sp,
                                            }))
                                            ////console.log(buys);
                                            ////console.log(sells);
                                        } catch (err) {

                                            console.log(err);
                                        }
                                    }

                                }

                            }
                        }
                    }catch(err){}
                    }
                }
                /*

                 */
            }
        }
        //  }
        ////console.log('wowolo2')
        for (var g in gos) {
            for (var symbol in gos[g]) {
                ////console.log('1 ' + symbol)
                //testing
                if (g != 'PAX' && g != 'USDC' && g != 'XRP'){
                try { //if (symbol == "GNTBNB"){
                    let book = thebooks[symbol]
                    let hb = 0;
                    let laless = 0;
                    let hbless = 0;
                    let bsover = 0;
                    let asover = 0;
                    for (var bid in book.bids) {
                        if (parseFloat(book.bids[bid].price) > hb) {
                            hbless = hb
                            hb = parseFloat(book.bids[bid].price);
                        }
                        if (parseFloat(book.bids[bid].price) > borders[symbol]) {
                            bsover += parseFloat(book.bids[bid].quantity);
                        }
                    }
                    let la = 50000000000000000000000;
                    for (var ask in book.asks) {
                        if (parseFloat(book.asks[ask].price) < la) {
                            laless = la
                            la = parseFloat(book.asks[ask].price)
                        }
                        if (parseFloat(book.asks[ask].price) < aorders[symbol]) {
                            asover += parseFloat(book.asks[ask].quantity);
                        }
                    }

                    console.log('1: ' + symbol + ' la: ' + la + ' hb: ' + hb)
                    ////console.log(aorders[symbol])
                                        if (renew[symbol] == undefined || renew[symbol] == true || (symbol != 'BNBUSDS' && ((hblesss[symbol] != hbless || lalesss[symbol] != laless) || ((las[symbol] != la && hbs[symbol] != hb) && (aorders[symbol] != la && borders[symbol] != hb))))) {
                        
                        console.log('2 ' + buyQtys[symbol] + ' ; ' + bsover);
                        if (buyQtys[symbol] * maxBetterVol < bsover || buyQtys[symbol] == undefined || Number.isNaN(bsover) ) {
                            console.log(buyQtys[symbol] + ' ; ' + bsover);
                            console.log('3')
                             hblesss[symbol] = hbless;
                            lalesss[symbol] = laless;
                            if (symbol.substring(symbol.length - 4, symbol.length) == g) {

                                asset = symbol.substring(0, symbol.length - 4)
                            } else {
                                asset = symbol.substring(0, symbol.length - 3)

                                //////console.log('asset: ' + asset)
                            } 
                            //console.log('asset: ' + asset)
                          
                            //bals = balscombined
                            //console.log('etheth')
                            //console.log(bals['ETH'])
                            //console.log(symbol.substring(symbol.length - 3, symbol.length))
                            //console.log(bals[symbol.substring(symbol.length - 3, symbol.length)])
                            if (true) {
                                //////console.log(precisions[symbol]);
                                //////console.log(filters[symbol])
                                //////console.log((bals[symbol.substring(symbol.length - 3, symbol.length)] / (hb * 1.0001) / Object.keys(gos[g]).length).toFixed(filters[symbol].stepSize - 1));
                                bp = (hb * 1.0001)
                                bp = bp.toFixed(filters[symbol].tickSize - 1)
                                let stop = (bp * stoploss)
                                stop = stop.toFixed(filters[symbol].tickSize - 1)
                                sp = (la * .995)
                                sp = sp.toFixed(filters[symbol].tickSize - 1)
                                //buyQty = ((bals[symbol.substring(symbol.length - 3, symbol.length)] / (hb * 1.0001) / Object.keys(gos[g]).length).toFixed(filters[symbol].stepSize - 1));
                                //testing
                                if (testing){
                                buyQty = ((bals[symbol.substring(symbol.length - 3, symbol.length)] * 0.99 / (hb * 1.0001) / 2.5).toFixed(filters[symbol].stepSize - 1));

                                }
                                else {
                                buyQty = (((bals[symbol.substring(symbol.length - 3, symbol.length)] * 0.99 / (hb * 1.0001) / Object.keys(gos[g]).length) / 1.75).toFixed(filters[symbol].stepSize - 1));

}
                                //console.log('buyQty: ' + buyQty)
                                let dontgo = false;
                                //////console.log(buyQty)
                                //////console.log(bp)
                                /*if (hb == bp){
                                    ////console.log('dontgo buy = ask');
                                    dontgo = true;
                                }*/
                                if (buyQty > maxOrder) {
                                    console.log('dontgo maxOrder ' + symbol)
                                    dontgo = true;
                                }
                                if ((buyQty * hb * 1.0001) < filters[symbol].minNotional) {
                                    console.log('dontgo minnotional ' + symbol)
                                    dontgo = true;
                                }
                                if (buyQty < filters[symbol].minQty) {

                                    console.log('dontgo minqty ' + symbol)
                                    dontgo = true;
                                }
                                 if (dontgo == false && !Number.isNaN(buyQty)) {
                                     
                                     renew[symbol] = false;
                                     if (buyOs[symbol] == undefined || (changed[symbol] == true  || changed[symbol] == undefined)){
                                    changed[symbol] = false;
                                    if (usddiff > -99999999999.00000000000001){
                                        if (usddiff > 0){
                                    if (avgBids[symbol] > 0.00000000000000000001){
                                    buyOs[symbol] = avgBids[symbol]  * 1.002;
                                }else {
                                    avgBids[symbol] = bp;
                                    buyOs[symbol] = bp   * 1.002;
                                }
                                        }
                                        else if (usddiff < 0){
                                   if (avgBids[symbol] > 0.00000000000000000001){
                                    buyOs[symbol] = avgBids[symbol]  * (1-(usddiff/100/(gocount / 4)));
                                }else {
                                    avgBids[symbol] = bp;
                                    buyOs[symbol] = bp   * (1-(usddiff/100/(gocount / 4)));
                                }
                            }
                            }else{
                                if (avgBids[symbol] > 0.00000000000000000001){
                                    buyOs[symbol] = avgBids[symbol]  * (1-(-0.5/100/(gocount / 4)));
                                }else {
                                    avgBids[symbol] = bp;
                                    buyOs[symbol] = bp   * (1-(-0.5/100/(gocount / 4)));
                                }
                            }
                        }
                        console.log(gocount)
                        console.log(usddiff)
                        console.log(avgBids[symbol])
                        console.log('buyO set: ' + buyOs[symbol])
                                divisor[symbol] = 1;

                                    stopp[symbol] = stop;
                                      let orders = (await client.openOrders({
                                        symbol: symbol,
                                    }))
                                                for (var o in orders) {
                                            if (orders[o].side == 'BUY'){
                                            ////console.log(orders[o])
                                            ////console.log('cancel')
                                            (await client.cancelOrder({
                                                symbol: symbol,
                                                orderId: orders[o].orderId,
                                            }))


                                        }
                                    }
                                    //lala++;
                                    try {
                                        buyQtys[symbol] = buyQty;
                                        aorders[symbol] = la;
                                        selling[symbol] = true;
                                        borders[symbol] = hb;
                                        //console.log
                                        (await client.order({
                                            symbol: symbol,
                                            side: 'BUY',
                                            quantity: buyQty,
                                            price: bp,
                                        }))
                                        /*
                (await client.order({
                  symbol: symbol,
                  side: 'SELL',
                  quantity: bals[asset],
                  price: sp,
                })) */
                                        ////console.log(buys);
                                        ////console.log(sells);
                                    } catch (err) {

                                        console.log(err);
                                    }
                                }
                            }


                            las[symbol] = la;
                            hbs[symbol] = hb;
                        }
                        /*

                         */
                    }
                }catch(err){

                }
            }
            }
        }

        ////console.log(count * 1 + ' intervals')
       
setTimeout(function() {
    doit();
}, 4000)
        count++;
    } catch (err) {
       
setTimeout(function() {
    doit();
}, 4000)
        console.log(err);
    }
}

setTimeout(function() {
    doit();
}, 10000)
function countDecimalPlaces(number) {
    var str = "" + number;
    if (str == '1e-7') {
        str = "0.0000001"
    } else {

        if (str == '1e-8') {
            str = "0.00000001"
        }
        var index = str.indexOf('.');


    }
    if (index >= 0) {
        return str.length - index;
    } else {
        return 1;
    }
}

let buyOs = {}

let divisor = {}
let stopp = {}
let buys = []
let sells = []
let las = {}
let hbs = {}
let aorders = {}
let borders = {}
let buyQtys = {}
let lalesss = {}
let hblesss = {}
